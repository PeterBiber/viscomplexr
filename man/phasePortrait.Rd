% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/VisComplex.R
\name{phasePortrait}
\alias{phasePortrait}
\title{Create phase portraits of complex functions}
\usage{
phasePortrait(
  exprText,
  xlim,
  ylim,
  invertFlip = FALSE,
  res = 150,
  blockSizePx = 2250000,
  tempDir = getwd(),
  nCores = detectCores(),
  pType = "pma",
  pi2Div = 9,
  logBase = exp(2 * pi/pi2Div),
  argOffset = 0,
  darkestShade = 0.1,
  lambda = 7,
  gamma = 0.9,
  stdSaturation = 0.8,
  hsvNaN = c(0, 0, 0.5),
  asp = 1,
  deleteTempFiles = TRUE,
  ...
)
}
\arguments{
\item{exprText}{The function to be visualized. It must be provided as a
character string containing an expression R can interpret as a function of
a complex number z. Examples: "sin(z)", "(z^2 - 1i)/(tan(z))", "1/4*z^2 -
10*z/(z^4+4)". You can even define your own functions e.g. for performing
iterative calculations. In this case, you need to use \code{\link{vapply}}
in exprText (see Details).}

\item{xlim}{The x limits (x1, x2) of the plot as a two-element numeric
vector. Follows exactly the same definition as in
\code{\link{plot.default}}. Here, \code{xlim} has to be interpreted as the
plot limits on the real axis.}

\item{ylim}{The y limits of the plot (y1, y2) to be used in the same way as
\code{xlim}. Evidently, \code{ylim} indicates the plot limits on the
imaginary axis.}

\item{invertFlip}{If \code{TRUE}, the function is mapped over a z plane,
which has been transformed to \code{1/z * exp(1i*pi)}. This is the
projection required to plot the north Riemann hemisphere in the way
proposed by \insertCite{wegert_visualcpx_2012;textual}{viscomplexr}, p. 41.
Defaults to \code{FALSE}. If this option is chosen, the axis ticks and
labels are suppressed (\code{xaxt = "n"}), because they do not make sense
in this setting.}

\item{res}{Desired resolution of the plot in dots per inch (dpi). Default is
150 dpi. All other things being equal, \code{res} has a strong influence on
computing times (double \code{res} means fourfold number of pixels to
compute). A good approach could be to make a plot with low resolution (e.g.
the default 150 dpi) first, adjust whatever required, and plot into a
graphics file with high resolution after that.}

\item{blockSizePx}{Number of pixels and corresponding complex values to be
processed at the same time (see Details). Default is 2250000. This value
gave good performance on older systems as well as on a high-end gaming
machine, but some tweaking for your individual system might even improve
things.}

\item{tempDir}{The name of the directory where the temporary files are stored
as a character string. Defaults to the current working directory. If
another directory is specified, it will be created if it does not exist (if
this is possible). It is advisable to locate this directory on a drive with
ample free space, especially when the purpose is to produce large high
resolution images. After completing the plot all temporary files are
deleted, but \code{tempDir} remains alive even if had been created by
\code{complexFunctionPlot}.}

\item{nCores}{Number of processor cores to be used in the parallel computing
tasks. Defaults to the maximum number of cores available. Any number
between 1 (serial computation) and the maximum number of cores available as
indicated by \code{parallel::detectCores} is acepted.}

\item{pType}{One of the three options for plotting "p", "pa", "pm", and "pma"
as a character string. Defaults to "pma". Option "p" produces a mere phase
plot, i.e. contains only colours for the complex numbers' arguments, but no
reference lines at all. the option "pa" introduces shading zones that
emphasize the arguments. These zones each cover an angle defined by
\code{2*pi/pi2Div}, where p2Div is another parameter of this function (see
there). These zones are shaded darkest at the lowest angle (counter
clockwise). Option "pm" displays the modulus by indicating zones, where the
moduli at the higher edge of each zone are in a constant ratio with the
moduli at the lower edge of the zone. Default is a ratio of almost exactly
2 (see parameter \code{logBase}) for details. At the lower edge, color
saturation is lowest and highest at the higher edge (see parameters
\code{darkestShade}, and \code{stdSaturation}). Option "pma" (default)
includes both shading schemes.}

\item{pi2Div}{Angle distance for the argument reference zones added for
\code{pType == "pma"}. The value has to be given as an integer (reasonably)
fraction of 2*pi (i.e. 360 degrees). the default is 9; thus, reference
zones are delineated by default in distances of 2*pi/9, i.e. (40 degrees),
starting with 0, i.e. the color red if not defined otherwise with the
parameter \code{argOffset}. In contrast to the borders delimiting the
modulus zones, the borders of the reference zones for the argument always
follow the same colour (by definition).}

\item{logBase}{Modulus ratio between the edges of the modulus reference zones
in \code{pType} \code{"pm"} and \code{"pma"}. As recommended by
\insertCite{wegert_visualcpx_2012;textual}{viscomplexr}, the default
setting is \code{logBase = exp(2*pi/pi2Div)}. This relation between the
parameters \code{logBase} and \code{pi2Div} ensures an analogue scaling of
the modulus and argument reference zones (see Details). Conveniently, for
the default \code{pi2Div == 9}, we obtain \code{logBase == 2.0099...},
which is very close to 2. Thus, the modulus at the higher edge of a given
zone is almost exactly two times the value at the lower edge.}

\item{argOffset}{The (complex number) argument in radians counterclockwise,
at which the argument reference zones are fixed. Default is 0, i.e. all
argument reference zones align to the centre of the red area.}

\item{darkestShade}{Darkest possible shading of modulus and angle reference
zones for \code{pType} \code{"pm"} and \code{"pma"}. It corresponds to the
value "v" in the \code{\link{hsv}} color model. \code{darkestShade == 0}
means no brightness at all, i.e. black, while \code{darkestShade == 1}
indicates maximum brightness. Defaults to 0.1, i.e. very dark, but hue
still discernible.}

\item{lambda}{Parameter steering the shading interpolation between the higher
and the lower edges of the the modulus and argument reference zones in
\code{pType} \code{"pm"} and \code{"pm"}. Should be > 0, default and
reference is \code{lambda == 7}. Values < 7 increase the contrast at the
zone borders, values > 7 weaken the contrast.}

\item{gamma}{Parameter for adjusting the combined shading of modulus and
argument reference zones in \code{pType} \code{"pma"}. Should be in the
interval \code{[0, 1]}. Default is 0.9. The higher the value, the more the
smaller of both shading values will dominate the outcome and vice versa.}

\item{stdSaturation}{Saturation value for unshaded hues which applies to the
whole plot in \code{pType} \code{"p"} and to the (almost) unshaded zones in
\code{pType} \code{"pm"} and \code{"p"}. This corresponds to the value "s"
in the \code{\link{hsv}} color model. Must be between 0 and 1, where 1
indicates full saturation and 0 indicates a neutral grey. Defaults to 0.8.}

\item{hsvNaN}{\code{\link{hsv}} coded color for being used in areas where the
function to be plotted is not defined. Must be given as a numeric vector
with containing the values h, s, and v in this order. Defaults to
\code{c(0, 0, 0.5)} which is a neutral grey.}

\item{asp}{Aspect ratio y/x as defined in \code{\link{plot.window}}. Default
is 1, ensuring an accurate representation of distances between points on
the screen.}

\item{deleteTempFiles}{If TRUE (default), all temporary files are deleted
after the plot is completed. Set it on FALSE only, if you know exactly what
you are doing - the temporary files can occupy large amounts of hard disk
space (see details).}

\item{...}{All parameters accepted by the \code{\link{plot.default}}
function.}
}
\description{
\code{phasePortrait} makes phase portraits of functions in the complex number
plane. It uses a technique often (but not quite correctly) called
\emph{domain coloring} (\url{https://en.wikipedia.org/wiki/Domain_coloring}).
While many varieties of this technique exist, this book relates closely to
the standards proposed by E. Wegert in his book \emph{Visual Complex
Functions} \insertCite{wegert_visualcpx_2012}{viscomplexr}. In a nutshell,
the argument (\code{\link{Arg}}) of any complex function value is displayed
as a color from the chromatic circle. The fundamental colours red, green, and
blue relate to the arguments (angles) of 0, 2/3pi, and 4/3pi (with smooth
color transitions inbetween), respectively. Options for displaying the
modulus (\code{\link{Mod}}) of the complex values and addtional reference
lines for the argument are available. This function is designed for being
used inside the framework of R base graphics. It makes use of parallel
computing, and depending on the desired resolution it may create extensive
sets of large temporary files (see Details and Examples).
}
\details{
This function is intended to be used inside the framework of R base graphics.
It plots into the active open graphics device where it will display the phase
plot of a user defined function as a raster image. If no graphics device is
open when called, the function will plot into the default graphics device.
This principle allows to utilize the full functionality of R base graphics.
All graphics parameters (\code{\link{par}}) can be freely set and the
function \code{phasePortrait} accepts all parameters that can be passed to
the \code{\link{plot.default}} function. This allows all kinds of plots -
from scientific representations with annotated axes and auxiliary lines,
notation, etc. to poster-like artistic pictures.\cr

\describe{
  \item{Mode of operation}{After being called, \code{phasePortrait} gets the
  size in inch of the plot region of the graphics device it is plotting into.
  With the parameter \code{res} which is the desired plot resolution in dpi,
  the horizontal and vertical number of pixels is known. As \code{xlim} and
  \code{ylim} are provided by the user, each pixel can be attributed a
  complex number z from the complex plane. In that way a two-dimensional
  array is built, where each cell represents a point of the complex plane,
  containing the corresponding complex number z. This array is set up in
  horizontal strips (i.e. split along the imaginary axis), each strip
  containing approximately \code{blockSizePx} pixels. In a parallel computing
  loop, the strips are constructed, saved as temporary files and immediately
  deleted from the RAM in order to avoid memory overflow. After that, the
  strips are sequentially loaded and subdivided into a number of chunks that
  corresponds to the number of registered parallel workers (parameter
  \code{nCores}). By parallely processing each chunk, the function
  \code{f(z)} defined by the user in \code{exprText} is applied to each cell
  of the strip. This results in an array of function values that has exactly
  the same size as the original strip. The new array is saved as a temporary
  file, the RAM is cleared, and the next strip is loaded. This continues
  until all strips are processed. In a similar way, all strips containing the
  function values are loaded sequentially, and in a parallel process the
  complex values are translated into colors which are stored in a raster
  object. While the strips are deleted from the RAM after processing, the
  color values obtained from each new strip are appended to the color raster.
  After all strips are processed, the raster is plotted into the plot region
  of the graphics device. If not explicitly defined otherwise by the user,
  all temporary files are deleted after that.
  }
  \item{Temporary file system}{By default, the above-mentioned temporary
  files are deleted after use. This will not happen, if the parameter
  \code{deleteTempFiles} is set to \code{FALSE} or if \code{phasePortrait}
  does not terminate properly. In both cases, you will find the files in the
  directory specified with the parameter \code{tempDir}. These files are
  \code{.RData} files, each one contains a two-dimensional array of complex
  numbers. The file names follow a strict convention, see the following
  examples:\cr\cr
  \code{0001zmat2238046385.RData}\cr
  \code{0001wmat2238046385.RData}\cr\cr
  Both names begin with '0001', indicating that the array's top line is the
  first line of the whole clipping of the complex number plane where the
  phase portrait relates to. The array which follows below can e.g. begin
  with a number like '0470', indicating that its first line is line number
  470 of the whole clipping. The number of digits for these line numbers is
  not fixed. It is determined by the greatest number required. Numbers with
  less digits are zero-padded. The second part of the file name is either
  \code{zmat} or \code{wmat}. The former indicates an array whose cells
  contain untransformed numbers of the complex number plane. The latter
  contains the values obtained from applying the function of interest to the
  first array. Thus, cells at the same position in both arrays exactly relate
  to each other. The third part of the file names is a ten-digit integer.
  This is a random number which all temporary files stemming from the same
  call of \code{phasePortrait} have in common. This guarantees that no
  temporary files will be confounded by the function, even if undeleted
  temporary files from previous runs are still present.
  }
  \item{HSV colour model}{For colour-coding the argument of a complex number,
  \code{phasePortrait} uses the \code{\link{hsv}} (hue, saturation, value)
  color model. Hereby, the arugument is mapped to a position on the chromatic
  circle, where the fundamental colours red, green, and blue relate to the
  arguments (angles) of 0, 2/3pi, and 4/3pi, respectively. This affects only
  the hue component of the color model. The value component is used for
  shading modulus and/or argument zones. The saturation component for all
  colours can be defined with the parameter \code{stdSaturation}.
  }
  \item{Zone definitions and shading}{In addition to displaying colors for
  the arguments of complex numbers, zones for the modulus and/or the argument
  are shaded for \code{pType} other than "p". The modulus zones are defined
  in a way that each zone covers moduli whose logarithms to the base
  \code{logBase} have the same integer part. Thus, from the lower edge of one
  modulus zone to its upper edge, the modulus multiplies with the value of
  \code{logBase}. The shading of a modulus zone depends on the fractional
  parts \code{x} of the above-mentioned logarithms, which cover the interval
  \code{[0, 1[}.
  This translates into the value component \code{v} of the \code{\link{hsv}}
  color model as follows:\cr\cr
  \code{v = darkestShade + (1 - darkestShade) * x^(1/lambda)}\cr\cr
  where \code{darkestShade} and \code{lambda} are parameters that can be
  defined by the user. Modifying the parameters \code{lambda} and
  \code{darkestShade} is useful for adjusting contrasts in the phase
  portraits. The argument zone definition is somewhat simpler: Each zone
  covers an angle domain of \code{2*pi / pi2Div}, the "zero reference" for
  all zones being \code{argOffset}. The angle domain of one zone is linearly
  mapped to a value \code{x} from the range \code{[0, 1[}.
  The value component of the colour to be displayed is calculated as a
  function of \code{x} with the same equation as shown above. In case the
  user has chosen \code{pType = "pma"}, x-values \code{xMod} and \code{xArg}
  are calculated separately for the modulus and the argument, respectively.
  They are transformed into preliminary v-values as follows:\cr\cr
  \code{vMod = xMod^(1/lambda)} and {vArg = xArg^(1/lambda)}\cr\cr
  From these, the final v value results as\cr\cr
  \code{v = darkestShade + (1-darkestShade) * (gamma * vMod * vArg +
  (1-gamma) * (1 - (1-vMod) * (1-vArg)))}\cr\cr
  The parameter \code{gamma} (range \code{[0, 1]}) determines they way how
  vMod and vArg are combined. The closer \code{gamma} is to one, the more
  the smaller of both values will dominate the outcome and vice versa.
  }
  \item{Defining more complicated functions with \code{\link{vapply}}}{You
  might want to write and use functions which require more code than a single
  statement like \code{(z-3)^2+1i*z}. In such cases, \code{\link{vapply}} can
  be used for wrapping your code. This is probably not the use of
  \code{\link{vapply}} intended by the developers, but it works nicely. The
  argument \code{exprText} must be a character string also here, but if has
  to have the follwing structure "vapply(z, function(z, \emph{other arguments
  if required}) \{\emph{define function code in here}\}, \emph{define other
  arguments here}, FUN.VALUE = complex(1))". See examples.
  }
}
}
\examples{
# Map the complex plane on itself
\dontrun{
x11(width = 8, height = 8)
phasePortrait("z", xlim = c(-2, 2), ylim = c(-2, 2),
xlab = "real", ylab = "imaginary")}


# A rational function
\dontrun{
x11(width = 10, height = 8)
phasePortrait("(2-z)^2*(-1i+z)^3*(4-3i-z)/((2+2i+z)^4)",
              xlim = c(-8, 8), ylim = c(-6.3, 4.3),
              xlab = "real", ylab = "imaginary")}


# Different pType options by exanple of the sine function
\dontrun{
x11(width = 9, height = 9)
op <- par(mfrow = c(2, 2), mar = c(2.1, 2.1, 2.1, 2.1))
phasePortrait("sin(z)", xlim = c(-pi, pi), ylim = c(-pi, pi),
              pType = "p",   main = "pType = 'p'",   axes = FALSE)
phasePortrait("sin(z)", xlim = c(-pi, pi), ylim = c(-pi, pi),
              pType = "pm",  main = "pType = 'pm'",  axes = FALSE)
phasePortrait("sin(z)", xlim = c(-pi, pi), ylim = c(-pi, pi),
              pType = "pa",  main = "pType = 'pa'",  axes = FALSE)
phasePortrait("sin(z)", xlim = c(-pi, pi), ylim = c(-pi, pi),
              pType = "pma", main = "pType = 'pma'", axes = FALSE)
par(op)}


# I called this one 'nuclear fusion'
\dontrun{
x11(width = 16/9*8, height = 8)
op <- par(mar = c(0, 0, 0, 0), omi = c(0.2, 0.2, 0.2, 0.2), bg = "black")
phasePortrait("cos((z + 1/z)/(1i/2 * (z-1)^10))",
              xlim = 16/9*c(-2, 2), ylim = c(-2, 2),
              axes = FALSE, xaxs = "i", yaxs = "i")
par(op)}


# Using vapply for defining functions that require more code.
# This is a Blaschke product with a sequence a of twenty numbers.
# See the documentation of the function vector2String for a more
# convenient space-saving definition of a.
\dontrun{
x11(width = 10, height = 8)
phasePortrait("vapply(z, function(z, a){
               return(prod(abs(a)/a * (a-z)/(1-Conj(a)*z)))
              }, a = c(0.12152611+0.06171533i,  0.53730315+0.32797530i,
                       0.35269601-0.53259644i, -0.57862039+0.33328986i,
                      -0.94623221+0.06869166i, -0.02392968-0.21993132i,
                       0.04060671+0.05644165i,  0.15534449-0.14559097i,
                       0.32884452-0.19524764i,  0.58631745+0.05218419i,
                       0.02562213+0.36822933i, -0.80418478+0.58621875i,
                      -0.15296208-0.94175193i, -0.02942663+0.38039250i,
                      -0.35184130-0.24438324i, -0.09048155+0.18131963i,
                       0.63791697+0.47284679i,  0.25651928-0.46341192i,
                       0.04353117-0.73472528i, -0.04606189+0.76068461i),
             FUN.VALUE = complex(1))",
             pType = "p",
             xlim = c(-4, 2), ylim = c(-2, 2),
             xlab = "real", ylab = "imaginary")}


# Interesting reunion with Benoit Mandelbrot. Another example
# for using vapply.
\dontrun{
x11(width = 11.7, height = 9/16*11.7)
op <- par(mar = c(0, 0, 0, 0), bg = "black")
phasePortrait(exprText = "vapply(z, FUN = ff <- function(z, n) {
                c  <- z
                zz <- 0
                for(i in c(1:n)) {
                  zz <- zz^2 + c
                }
                return(zz)
              }, n = 52,
              FUN.VALUE = complex(1))",
              xlim = c(-0.847, -0.403), ylim = c(0.25, 0.50),
              axes = TRUE, pType = "pma",
              hsvNaN = c(0, 0, 0), xaxs = "i", yaxs = "i")
par(op)}


}
\references{
\insertAllCited{}
}
